# Introduction to JSX

- ğŸ–¥  [Slides](https://docs.google.com/presentation/d/1ODDEITggZ5zdOkYu-s-XwZkSBqRqhPuXpuwsE5Ng0oU/edit?usp=sharing)
- [Exercise](https://codesandbox.io/s/react-jsx-intro-exercise-cfthh)
- ğŸ“¦ [Homework](https://codesandbox.io/s/redi-react-2021-jsx-homework-5qu7v)
- ğŸŒ [Reference site for homework](https://redi-react-2021-jsx-homework.netlify.app/)
- âœï¸ [One potential solution for the homework](https://codesandbox.io/s/redi-react-2021-jsx-solution-gsli2)
- [Exercise: Conditionals](https://codesandbox.io/s/redi-react-jsx-conditionals-mgf0x)

One of the first things you probably noticed about React code is that it looks like the component function is returning HTML. This HTML-like syntax is actually called JSX.

## What Is JSX?

JSX is a syntax invented for React that looks very similar to (X)HTML. It allows you to create elements by writing in a familiar-looking syntax, instead of writing out function calls by hand. The HTML-like syntax actually compiles down to real JavaScript.

Did you notice how there are no quotes around the â€œHTMLâ€? Thatâ€™s becauseÂ **itâ€™s not a string.**Â The lack of quotes is not just a trick, either. React isÂ *not*Â parsing the tags and converting them into HTML.

It looks like HTML. In reality though, JSX is just a nice syntax for function calls that create DOM elements.

So what is React actually doing here? How does this work?

## JSX Is Compiled to JavaScript

The JSX elements you write are actually compiled down to JavaScript by a tool called Babel. Babel is a compiler that transforms code into valid ES5 JavaScript that all browsers can understand, and itâ€™s bundled in with projects created by Create React App.

After you runÂ `npm start`, a tool called Webpack is watching for files to change. When they do, it feeds those files into Babel, which turns JSX into JS, and sends it to your browser via the development server running on port 3000.

Each JSX element becomes a function call, where its arguments are its attributes (â€œpropsâ€) and its contents (â€œchildrenâ€).

Hereâ€™s an example of a simple React component that returns some JSX:

```jsx
function Hello() {  return <span>Hello!</span>;}
```

And here is the JavaScript generated by the Babel compiler:

```jsx
function Hello() {
	return React.createElement(
    'span',
		{},   
		'Hello!' 
	);
}
```

TheÂ `React.createElement`Â function signature looks like this:

```jsx
React.createElement(
  string|element,  [propsObject],  [children...]
)
```

TheÂ `string|element`Â can be a string describing an HTML or SVG tag (likeÂ `'div'`Â orÂ `'span'`), or it can be a component a.k.a. function (likeÂ `HelloWorld`, with no quotes).

TheÂ `propsObject`Â andÂ `children`Â are optional, and you can also supply more than one child by passing additional arguments:

```jsx
function HelloWorld() {
	return React.createElement(
    'div',
		{},
		'Hello',
		'World'
	);
}
```

Try it yourself! Rewrite theÂ `HelloWorld`Â component to callÂ `React.createElement`Â instead of returning JSX.

```jsx
function HelloWorld() {
	return React.createElement(
    /* fill this in */  
	)
;}
```

Here is a slightly more complicated bit of JSX, and a preview of whatâ€™s to come. You can see that it references a function parameter namedÂ `props`. We havenâ€™t talked about props yet, but this is the way you pass arguments to React components.

```jsx
function SongName(props) {
	return (
    <span className='song-name'>
			{props.song.name}
		</span>
	);
}
```

And here is what it compiles to:

```jsx
function SongName(props) {
	return (
    React.createElement('span',
			{ className: 'song-name' },
			props.song.name
		)
  );
}
```

See how JSX is essentially a nice shorthand for writing function calls? You donâ€™t even have to use JSX if you donâ€™t want to â€“ you can write out these function calls manually.

Your first instinct might be to avoid writing JSX because you donâ€™t like the look of â€œHTML in JS.â€ Maybe youâ€™d rather write real JavaScript function calls, because it feels more â€œpureâ€ somehow. I suggest giving JSX an honest try before you give up on it.

Writing out theÂ `React.createElement`Â calls is not a common approach in the React community. Essentially all React developers use JSX, which means code that you see in the wild (on GitHub, Stack Overflow, etc.) is likely to be written with it.

# Working With JSX

## Composing Components

JSX, like HTML, allows you to nest elements inside of one another. This is probably not a big surprise.

Letâ€™s refactor theÂ `HelloWorld`Â component from earlier to demonstrate how composition works. Hereâ€™s the originalÂ `HelloWorld`:

```jsx
function HelloWorld() {
  return <div>Hello World!</div>;
}
```

Leaving theÂ `HelloWorld`Â component intact for now, create twoÂ *new*Â components: one namedÂ `Hello`and one namedÂ `World`.Â `Hello`Â should renderÂ `<span>Hello</span>`Â andÂ `World`Â should renderÂ `<span>World</span>`. You can basically copy-and-paste theÂ `HelloWorld`Â component and just change the text and the function name.

Go ahead and try making that change yourself. Iâ€™ll wait.

â€¦

â€¦

Got it?

Itâ€™s important to actuallyÂ *type this stuff out*Â and try it yourself! Donâ€™t just read while nodding along, because you wonâ€™t actually learn it that way. Itâ€™s very easy to look at code and think, â€œYep, that all makes sense.â€ Youâ€™ll never know if you truly understand until youÂ *try it*.

Your two new components should look like this:

```jsx
function Hello() {
  return <span>Hello</span>;
}
function World() {
  return <span>World</span>;
}
```

Now, change theÂ `HelloWorld`Â component to use the two new components you just created. It should look something like this:

```jsx
function HelloWorld() {
  return (
    <div>
      <Hello /> <World />!
    </div>
  );
}
```

Assuming the app is still running, the page should automatically refresh. If not, make sure the app is running (runÂ `npm start`Â if itâ€™s not).

You should see the same â€œHello World!â€ as before. Congrats!

I know this seems painfully simple, but there are some lessons here, I promise.

The next few examples depend upon theÂ `Hello`Â andÂ `World`Â components that you should have created above, so make sure those exist before you continue.

### Wrap JSX with Parentheses

A quick note on formatting: you might notice I wrapped the returned JSX inside parentheses,Â `()`. This isnâ€™t strictly necessary, but if you leave off the parens, the opening tag must be on the same line as the return, which looks a bit awkward:

```jsx
function HelloWorld() {
  return <div>
      <Hello /> <World />!
   </div>;
}
```

Just for kicks, try moving theÂ `<div>`Â onto its own line, without the surrounding parens:

```jsx
function HelloWorld() {
  return 
		<div>
      <Hello /> <World />!
   </div>;
}
```

This will fail with an error.

If you look in the browser console, youâ€™ll also likely see a warning about â€œNothing was returned from render.â€

This is because JavaScript assumes you wanted a semicolon after that return (because of the newline), effectively turning it into this, which returns undefined:

```jsx
function HelloWorld() {
  return;
  <div>
    <Hello /> <World />!
  </div>;
}
```

So: feel free to format your JSX however you like, but if itâ€™s on multiple lines, I recommend wrapping it in parentheses.

### Return a Single Element

Notice how the two components are wrapped in aÂ `<div>`Â in theÂ `HelloWorld`Â example:

```jsx
function HelloWorld() {
  return (
    <div>
      <Hello /> <World />!
    </div>
  );
}
```

Hereâ€™s a little exercise: try removing theÂ `<div>`Â wrapper and see what happens. You should get this error:

> Adjacent JSX elements must be wrapped in an enclosing tag.
> 

If this seems surprising, remember that JSX is compiled to JS before it runs:

```jsx
// This JSX:
function HelloWorld() {
  return (<Hello/> <World/>);
}

// Becomes this JS:
function HelloWorld() {
  return (
    React.createElement(Hello, null)
    React.createElement(World, null)
  );
}
```

Returning two things at once is pretty obviously not gonna work. So that leads to this very important rule:

> A component function must return a single element.
> 

But wait! Could you return an array? Itâ€™s just JavaScript after allâ€¦

```jsx
// This JSX:
function HelloWorld() {
  return [<Hello />, <World />];
}

// Would turn into this JS
// (notice the brackets).
function HelloWorld() {
  return [
    React.createElement(
      Hello,
      null
    ),
    React.createElement(World, null)
  ];
}
```

Try it out! It renders correctly.

But if you open up the browser console, youâ€™ll see a warning:

> Each child in an array or iterator should have a unique â€œkeyâ€ prop.
> 

As the warning suggests, React requires a uniqueÂ `key`Â prop for each JSX element in an array. Weâ€™ll learn more about theÂ `key`Â prop later on, but in the meantime, there are two ways to solve this problem: either wrap the elements in a single enclosing tag, or wrap them in a fragment.

### Wrap With a Tag

The most obvious way to return multiple elements is to wrap them in an enclosing tag, like aÂ `<div>`orÂ `<span>`. However, it has the side effect of influencing the DOM structure.

For example, this React componentâ€¦

```jsx
function HelloWorld() {
  return (
    <div>
      <Hello/> <World/>!
    </div>
  );
}
â€¦will render a DOM structure like this:

<div>
  <span>Hello</span>
  <span>World</span>
</div>
```

â€¦will render a DOM structure like this:

```jsx
<div>
  <span>Hello</span>
  <span>World</span>
</div>
```

A lot of the time, this is perfectly fine. But sometimes, you wonâ€™t want to have a wrapper element, like if you have a component that returns two table cells:

```jsx
function NameCells() {
  return (
    <td>First Name</td>
    <td>Last Name</td>
  );
}
```

You canâ€™t wrap these elements in aÂ `<div>`, because theÂ `<td>`Â table cells need to be direct descendants of aÂ `<tr>`Â table row. How can you combine them?

### Fragments

Reactâ€™s answer is theÂ *fragment*. This component was added in React 16.2, and can be used like this:

```jsx
function NameCells() {
  return (
    <React.Fragment>
      <td>First Name</td>
      <td>Last Name</td>
    </React.Fragment>
  );
}
```

After rendering, theÂ `React.Fragment`Â component will â€œdisappearâ€, leaving only the children inside it, so that the DOM structure will have no wrapper components.

Fragments make it easier to produce valid HTML (such as keepingÂ `<td>`Â elements directly insideÂ `<tr>`s), and they keep the DOM structure flatter which makes it easier to write semantic HTML (which is also usually more accessible HTML).

### Fragment Syntax

If you thinkÂ `React.Fragment`Â looks clunky, I donâ€™t blame you. JSX supports a special syntax that looks like an â€œempty tagâ€ and is much nicer to write:

```jsx
function NameCells() {
  return (
    <>
      <td>First Name</td>
      <td>Last Name</td>
    </>
  );
}
```

ThisÂ `<></>`Â syntax is the preferred way to write fragments, and this feature will be available as long as youâ€™re working in a new-enough project (Babel 7+, Create React App 2+)

### JavaScript in JSX

You can insert real JavaScript expressions inside JSX code, and in fact, youâ€™ll do this quite often. Surround JavaScript with single braces like this:

```jsx
function SubmitButton() {
  const buttonLabel = "Submit";
  return (
    <button>{buttonLabel}</button>
  );
}
```

Remember that this will be compiled to JavaScript, which means that the JS inside the braces must be anÂ *expression*. An expression produces a value. These are expressions:

```jsx
1 + 2
buttonLabel
aFunctionCall()
aFunctionName
```

Each of these results in a single value. In contrast,Â *statements*Â do not produce values and canâ€™t be used inside JSX. Here are some examples of statements:

```jsx
const a = 5
if(true) { 17; }
while(i < 7) { i++ }
```

None of these things produces a value.Â `const a = 5`Â declares a variable with the value 5, but it does notÂ *return*Â that value.

Another way to think of statement vs expression is thatÂ *expressions*Â can be on the right hand of an assignment, but statements cannot.

```jsx
// These aren't valid JS:
a = let b = 5;
a = if(true) { 17; }
```

You can also ask yourself, â€œCould IÂ `return`Â this value from a function?â€ If the answer is yes, thatâ€™s an expression and you can write it inside JSX withinÂ `{single braces}`.
